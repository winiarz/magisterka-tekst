
\section { Optymalizacje podstawowej implementacji }

\subsection { Siła między punktem a samym sobą }
Obliczając siły między punktami może zdarzyć się sytuacja, że dwa punktty mają dokładnie to samo położenie. Chcąc obliczyć siłę grawitacji między nimi dochodzimy do wniosku, żejest to niewykonalne ze względu na konieczność dzielenia przez odległość równą 0. Wykonanie takiego dzielenia jest możliwe na procesorze graficznym, ale daje wynik NaN (ang. not a number). Dalsze obliczenia z tym wynikiem powodują utratę pozostałych wyników. Podstawowa implementacja jest zabezpieczona przed tą sytuacją za pomocą instrukcji ``if'', która sprawdza czy odległość między punktami jest większa od 0.\linebreak
 // dlaczego if'y są złe

 

Problem ten można rozwiązać dodając do kwadratu obliczonej odległości bardzo małą liczbę ( epsilon ). Dla potrzeb mojej implementacji zostało przyjęte epsilon = 0,0000001. W tej sytuacji można bezpiecznie dzielić przez odległość, gdyż jest większa od zera. Przy liczeniu siły między punktem a samym sobą obliczona siła będzie równa zero, ponieważ różnica położeń jest wektorem zerowym. W pozostałych przypadkach ze względu na małą wartość epsilon obliczona siła może nieznacznie różnić się od poprawnej wartości.

Takie podejście wymaga dodatkowego dodawania przy każdym obliczaniu odległości, jednak jest to kosz znacznie mniejszy od sprawdzania warunku

Usyskane przyspieszenie prezentuje tabela:
\linebreak

%\linebreak
Opisana wyżej optymalizacja powoduje wzrost wydajności około ??? razy. 


\subsection { ??? }
Licząc wypadkową siłę działającą na wybrany punkt przy każdym obliczaniu siły grawitacji mnożymy przez jego masę. Następnie zaś dzielimy przez tą samą masę otrzymując przyspieszenie. Dzięki prawom działań na wektorach te dwie operacje możemy pominąć bez zmiany wyniku. Przyspieszenie uzyskane dzięki tej modyfikacji przedstawia tabela:


\subsection { Odwrotność pierwiastka }
OpenCL ma zestaw funkcji. Są wśród nich funkcje trygonometryczne, logarytmy, zaokrąglenia, wartość bezwzględna itp. Na kartach graficznych wiele z nich jest przyspieszanych sprzętowo. Jedną z nich jest funkcja sqrt - pierwiastek kwadratowy z liczby używany w podstawowej implementacji do obliczania odległości. Po podniesieniu do 3 potęgi trzeba wykonać dość kosztowną operację dzielenia. Bardziej odpowiednią funckją jest zatem rsqrt ( odwrotność pierwiastka ). Przyspieszenie przedstawia tabela.
